<?xml version="1.0"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN"
      "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html>
<head>
  <meta http-equiv="Content-Type" content="" />
  <title>Getting Started</title>
</head>

<body>
<h1>Getting Started</h1>

<p>This guide assumes you are familiar with unit-testing and <a
href="http://junit.org/">JUnit</a>.</p>

<p>For a simple example we are going to test a publish/subscribe message
system. A Publisher sends objects to zero or more Subscribers.  We want to
test the Publisher, which involves testing its interactions with its
Subscribers.</p>

<p>The Subscriber interface looks like this:</p>

<div class="Source Java">
<pre>interface Subscriber {
    void receive(Object message);
}</pre>
</div>

<p>We will test that a Publisher sends a message to a single registered
Subscriber. To test interactions between the Publisher and the Subscriber we
will use a mock Subscriber object.</p>

<p>First we must import the jMock classes, define our test fixture class and
define a test case method.</p>

<div class="Source Java">
<pre>import org.jmock.*;

class PublisherTest extends MockObjectTestCase {
    public void testOneSubscriberReceivesAMessage() {
    }
}</pre>
</div>

<p>We will now write the body of the
<code>testOneSubscriberReceivesAMessage</code> method.</p>

<p>We first <i>set up</i> the context in which our test will execute. We
create a Publisher to test.  We create a mock Subscriber that should receive
the message.  We then register the Subscriber with the Publisher. Finally we
create a message object to publish.</p>

<div class="Source Java">
<pre>Mock mockSubscriber = new Mock(Subscriber.class);
Publisher publisher = new Publisher();
publisher.add( (Subscriber)mockSubscriber.proxy() );

final Object message = new Object();</pre>
</div>

<p>Next we define <i>expectations</i> on the mock Subscriber that specify the
methods that we expect to be called upon it during the test run.  We expect
the receive method to be called with a single argument, the message that will
be sent.  The <code>same</code> method is defined in the MockObjectTestCase
class and specifies that we expect the argument to be the same object as
<var>message</var>. We don't need to specify what will be returned from the
receive method because it has a void return type.</p>

<div class="Source Java">
<pre>mockSubscriber.expects(once()).method("receive").with( same(message) );</pre>
</div>

<p>We then <i>execute</i> the code that we want to test.</p>

<div class="Source Java">
<pre>publisher.publish(message);</pre>
</div>

<p>Finally we <i>verify</i> that the mock Subscriber was called as expected. 
If we do not verify, our test will detect incorrect calls to the mock
Subscriber but not the complete lack of calls.</p>

<div class="Source Java">
<pre>mockSubscriber.verify();</pre>
</div>

<p>Here is the complete test.</p>

<div class="Source Java">
<pre>import org.jmock.*;

class PublisherTest extends MockObjectTestCase {
    public void testOneSubscriberReceivesAMessage() {
        // set up
        Mock mockSubscriber = new Mock(Subscriber.class);
        Publisher publisher = new Publisher();
        publisher.add((Subscriber) mockSubscriber.proxy());
        
        final Object message = new Object();
        
        // expectations
        mockSubscriber.expects(once()).method("receive").with( same(message) );
        
        // execute
        publisher.publish(message);
        
        // verify
        mockSubscriber.verify();
    }
}</pre>
</div>

<p>That concludes this quick introduction.  More advanced topics are covered
in <a href="docs.html#tutorials">other tutorials</a>.</p>
</body>
</html>
